{"ast":null,"code":"'use strict';\n\nconst Reach = require('./reach');\n\nconst Types = require('./types');\n\nconst Utils = require('./utils');\n\nconst internals = {\n  needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  let clone = internals.clone;\n  let seen = _seen;\n\n  if (options.shallow) {\n    if (options.shallow !== true) {\n      return internals.cloneWithShallow(obj, options);\n    }\n\n    clone = value => value;\n  } else if (seen) {\n    const lookup = seen.get(obj);\n\n    if (lookup) {\n      return lookup;\n    }\n  } else {\n    seen = new Map();\n  } // Built-in object types\n\n\n  const baseProto = Types.getInternalProto(obj);\n\n  if (baseProto === Types.buffer) {\n    return Buffer && Buffer.from(obj); // $lab:coverage:ignore$\n  }\n\n  if (baseProto === Types.date) {\n    return new Date(obj.getTime());\n  }\n\n  if (baseProto === Types.regex) {\n    return new RegExp(obj);\n  } // Generic objects\n\n\n  const newObj = internals.base(obj, baseProto, options);\n\n  if (newObj === obj) {\n    return obj;\n  }\n\n  if (seen) {\n    seen.set(obj, newObj); // Set seen, since obj could recurse\n  }\n\n  if (baseProto === Types.set) {\n    for (const value of obj) {\n      newObj.add(clone(value, options, seen));\n    }\n  } else if (baseProto === Types.map) {\n    for (const [key, value] of obj) {\n      newObj.set(key, clone(value, options, seen));\n    }\n  }\n\n  const keys = Utils.keys(obj, options);\n\n  for (const key of keys) {\n    if (key === '__proto__') {\n      continue;\n    }\n\n    if (baseProto === Types.array && key === 'length') {\n      newObj.length = obj.length;\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor) {\n      if (descriptor.get || descriptor.set) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else if (descriptor.enumerable) {\n        newObj[key] = clone(obj[key], options, seen);\n      } else {\n        Object.defineProperty(newObj, key, {\n          enumerable: false,\n          writable: true,\n          configurable: true,\n          value: clone(obj[key], options, seen)\n        });\n      }\n    } else {\n      Object.defineProperty(newObj, key, {\n        enumerable: true,\n        writable: true,\n        configurable: true,\n        value: clone(obj[key], options, seen)\n      });\n    }\n  }\n\n  return newObj;\n};\n\ninternals.cloneWithShallow = function (source, options) {\n  const keys = options.shallow;\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const seen = new Map();\n\n  for (const key of keys) {\n    const ref = Reach(source, key);\n\n    if (typeof ref === 'object' || typeof ref === 'function') {\n      seen.set(ref, ref);\n    }\n  }\n\n  return internals.clone(source, options, seen);\n};\n\ninternals.base = function (obj, baseProto, options) {\n  if (options.prototype === false) {\n    // Defaults to true\n    if (internals.needsProtoHack.has(baseProto)) {\n      return new baseProto.constructor();\n    }\n\n    return baseProto === Types.array ? [] : {};\n  }\n\n  const proto = Object.getPrototypeOf(obj);\n\n  if (proto && proto.isImmutable) {\n    return obj;\n  }\n\n  if (baseProto === Types.array) {\n    const newObj = [];\n\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n\n    return newObj;\n  }\n\n  if (internals.needsProtoHack.has(baseProto)) {\n    const newObj = new proto.constructor();\n\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n\n    return newObj;\n  }\n\n  return Object.create(proto);\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@hapi/hoek/lib/clone.js"],"names":["Reach","require","Types","Utils","internals","needsProtoHack","Set","set","map","weakSet","weakMap","module","exports","clone","obj","options","_seen","seen","shallow","cloneWithShallow","value","lookup","get","Map","baseProto","getInternalProto","buffer","Buffer","from","date","Date","getTime","regex","RegExp","newObj","base","add","key","keys","array","length","descriptor","Object","getOwnPropertyDescriptor","defineProperty","enumerable","writable","configurable","source","assign","ref","prototype","has","constructor","proto","getPrototypeOf","isImmutable","setPrototypeOf","create"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Reach = require('./reach');\nconst Types = require('./types');\nconst Utils = require('./utils');\n\n\nconst internals = {\n    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    let clone = internals.clone;\n    let seen = _seen;\n\n    if (options.shallow) {\n        if (options.shallow !== true) {\n            return internals.cloneWithShallow(obj, options);\n        }\n\n        clone = (value) => value;\n    }\n    else if (seen) {\n        const lookup = seen.get(obj);\n        if (lookup) {\n            return lookup;\n        }\n    }\n    else {\n        seen = new Map();\n    }\n\n    // Built-in object types\n\n    const baseProto = Types.getInternalProto(obj);\n    if (baseProto === Types.buffer) {\n        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$\n    }\n\n    if (baseProto === Types.date) {\n        return new Date(obj.getTime());\n    }\n\n    if (baseProto === Types.regex) {\n        return new RegExp(obj);\n    }\n\n    // Generic objects\n\n    const newObj = internals.base(obj, baseProto, options);\n    if (newObj === obj) {\n        return obj;\n    }\n\n    if (seen) {\n        seen.set(obj, newObj);                              // Set seen, since obj could recurse\n    }\n\n    if (baseProto === Types.set) {\n        for (const value of obj) {\n            newObj.add(clone(value, options, seen));\n        }\n    }\n    else if (baseProto === Types.map) {\n        for (const [key, value] of obj) {\n            newObj.set(key, clone(value, options, seen));\n        }\n    }\n\n    const keys = Utils.keys(obj, options);\n    for (const key of keys) {\n        if (key === '__proto__') {\n            continue;\n        }\n\n        if (baseProto === Types.array &&\n            key === 'length') {\n\n            newObj.length = obj.length;\n            continue;\n        }\n\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n            if (descriptor.get ||\n                descriptor.set) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else if (descriptor.enumerable) {\n                newObj[key] = clone(obj[key], options, seen);\n            }\n            else {\n                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });\n            }\n        }\n        else {\n            Object.defineProperty(newObj, key, {\n                enumerable: true,\n                writable: true,\n                configurable: true,\n                value: clone(obj[key], options, seen)\n            });\n        }\n    }\n\n    return newObj;\n};\n\n\ninternals.cloneWithShallow = function (source, options) {\n\n    const keys = options.shallow;\n    options = Object.assign({}, options);\n    options.shallow = false;\n\n    const seen = new Map();\n\n    for (const key of keys) {\n        const ref = Reach(source, key);\n        if (typeof ref === 'object' ||\n            typeof ref === 'function') {\n\n            seen.set(ref, ref);\n        }\n    }\n\n    return internals.clone(source, options, seen);\n};\n\n\ninternals.base = function (obj, baseProto, options) {\n\n    if (options.prototype === false) {                  // Defaults to true\n        if (internals.needsProtoHack.has(baseProto)) {\n            return new baseProto.constructor();\n        }\n\n        return baseProto === Types.array ? [] : {};\n    }\n\n    const proto = Object.getPrototypeOf(obj);\n    if (proto &&\n        proto.isImmutable) {\n\n        return obj;\n    }\n\n    if (baseProto === Types.array) {\n        const newObj = [];\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    if (internals.needsProtoHack.has(baseProto)) {\n        const newObj = new proto.constructor();\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    return Object.create(proto);\n};\n"]},"metadata":{},"sourceType":"script"}