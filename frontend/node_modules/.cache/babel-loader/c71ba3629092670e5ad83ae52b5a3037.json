{"ast":null,"code":"'use strict';\n\nconst Assert = require('./assert');\n\nconst Clone = require('./clone');\n\nconst Merge = require('./merge');\n\nconst Reach = require('./reach');\n\nconst internals = {};\n\nmodule.exports = function (defaults, source, options = {}) {\n  Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');\n  Assert(typeof options === 'object', 'Invalid options: must be an object');\n\n  if (!source) {\n    // If no source, return null\n    return null;\n  }\n\n  if (options.shallow) {\n    return internals.applyToDefaultsWithShallow(defaults, source, options);\n  }\n\n  const copy = Clone(defaults);\n\n  if (source === true) {\n    // If source is set to true, use defaults\n    return copy;\n  }\n\n  const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;\n  return Merge(copy, source, {\n    nullOverride,\n    mergeArrays: false\n  });\n};\n\ninternals.applyToDefaultsWithShallow = function (defaults, source, options) {\n  const keys = options.shallow;\n  Assert(Array.isArray(keys), 'Invalid keys');\n  const seen = new Map();\n  const merge = source === true ? null : new Set();\n\n  for (let key of keys) {\n    key = Array.isArray(key) ? key : key.split('.'); // Pre-split optimization\n\n    const ref = Reach(defaults, key);\n\n    if (ref && typeof ref === 'object') {\n      seen.set(ref, merge && Reach(source, key) || ref);\n    } else if (merge) {\n      merge.add(key);\n    }\n  }\n\n  const copy = Clone(defaults, {}, seen);\n\n  if (!merge) {\n    return copy;\n  }\n\n  for (const key of merge) {\n    internals.reachCopy(copy, source, key);\n  }\n\n  const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;\n  return Merge(copy, source, {\n    nullOverride,\n    mergeArrays: false\n  });\n};\n\ninternals.reachCopy = function (dst, src, path) {\n  for (const segment of path) {\n    if (!(segment in src)) {\n      return;\n    }\n\n    const val = src[segment];\n\n    if (typeof val !== 'object' || val === null) {\n      return;\n    }\n\n    src = val;\n  }\n\n  const value = src;\n  let ref = dst;\n\n  for (let i = 0; i < path.length - 1; ++i) {\n    const segment = path[i];\n\n    if (typeof ref[segment] !== 'object') {\n      ref[segment] = {};\n    }\n\n    ref = ref[segment];\n  }\n\n  ref[path[path.length - 1]] = value;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@hapi/hoek/lib/applyToDefaults.js"],"names":["Assert","require","Clone","Merge","Reach","internals","module","exports","defaults","source","options","shallow","applyToDefaultsWithShallow","copy","nullOverride","undefined","mergeArrays","keys","Array","isArray","seen","Map","merge","Set","key","split","ref","set","add","reachCopy","dst","src","path","segment","val","value","i","length"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\nconst Clone = require('./clone');\nconst Merge = require('./merge');\nconst Reach = require('./reach');\n\n\nconst internals = {};\n\n\nmodule.exports = function (defaults, source, options = {}) {\n\n    Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');\n    Assert(typeof options === 'object', 'Invalid options: must be an object');\n\n    if (!source) {                                                  // If no source, return null\n        return null;\n    }\n\n    if (options.shallow) {\n        return internals.applyToDefaultsWithShallow(defaults, source, options);\n    }\n\n    const copy = Clone(defaults);\n\n    if (source === true) {                                          // If source is set to true, use defaults\n        return copy;\n    }\n\n    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;\n    return Merge(copy, source, { nullOverride, mergeArrays: false });\n};\n\n\ninternals.applyToDefaultsWithShallow = function (defaults, source, options) {\n\n    const keys = options.shallow;\n    Assert(Array.isArray(keys), 'Invalid keys');\n\n    const seen = new Map();\n    const merge = source === true ? null : new Set();\n\n    for (let key of keys) {\n        key = Array.isArray(key) ? key : key.split('.');            // Pre-split optimization\n\n        const ref = Reach(defaults, key);\n        if (ref &&\n            typeof ref === 'object') {\n\n            seen.set(ref, merge && Reach(source, key) || ref);\n        }\n        else if (merge) {\n            merge.add(key);\n        }\n    }\n\n    const copy = Clone(defaults, {}, seen);\n\n    if (!merge) {\n        return copy;\n    }\n\n    for (const key of merge) {\n        internals.reachCopy(copy, source, key);\n    }\n\n    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;\n    return Merge(copy, source, { nullOverride, mergeArrays: false });\n};\n\n\ninternals.reachCopy = function (dst, src, path) {\n\n    for (const segment of path) {\n        if (!(segment in src)) {\n            return;\n        }\n\n        const val = src[segment];\n\n        if (typeof val !== 'object' || val === null) {\n            return;\n        }\n\n        src = val;\n    }\n\n    const value = src;\n    let ref = dst;\n    for (let i = 0; i < path.length - 1; ++i) {\n        const segment = path[i];\n        if (typeof ref[segment] !== 'object') {\n            ref[segment] = {};\n        }\n\n        ref = ref[segment];\n    }\n\n    ref[path[path.length - 1]] = value;\n};\n"]},"metadata":{},"sourceType":"script"}